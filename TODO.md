1. По всему коду найти упоминание Украинских фио и т.д., сверить с заданием (там RU, BY, KZ !!! нету нигде UA, а также нету таких межславянских фамилия как "король", что за бред, проверь и этот список)
2. Привести в порядок симтомы и смежные анализы, потому что сейчас это капец по типу "сильная тяжесть в задняя части стопа
слабая тяжесть в передняя части спина
слабая слабость в правая части бедро"
И ещё и подряд иногда такое идёт у одного человека. Очень редко бывает чтобы были симптомы прямо везде. Ещё и анализы к ним не соответствующие. Переделать эту часть генерации чуть ли не полностью, чтобы всё было по "словарям" но очень красиво и согласовано.
3. Сделать систему генерации паспорта согласно следующему тексту
```
Похоже, у вас смешались две вещи: 1) реальная ошибка валидации (в логе видно “Неверный формат паспорта для страны ru”), 2) незавершённая/упрощённая модель паспорта. Сначала про причину текущей ошибки, затем — как осмысленно сделать паспорта “как в жизни” (серия=регион+год выдачи, код подразделения, дата выдачи, возрастные замены в 14/20/45 и т.д.), и как обновить валидатор.

Что именно ломает валидацию сейчас
- В DataValidator.validate_record вы вытаскиваете страну так: country = record.get("passport_country", "ru"). Но в сгенерированную запись вы не кладёте ключ passport_country вообще. В generate_visit_record в record у вас есть только 'passport_data', а 'country' есть лишь внутри client. Поэтому для всех записей страна становится “ru” по умолчанию. Как только генератор отдал белорусский или казахстанский номер, валидатор проверяет его по RU-паттерну и валится предупреждением. Это и есть источник сообщения “Неверный формат паспорта для страны ru” на произвольной записи 49986.
- Минимальный фикс: добавьте в record поле 'passport_country': client['country'] при сборке записи. Тогда для BY/KZ будет использоваться правильный регэксп.
- Дополнительно: если у вас BY/KZ клиенты, подумайте, нужен ли им СНИЛС. Сейчас вы валидируете СНИЛС без оглядки на страну. Если BY/KZ допустимы, СНИЛС надо либо делать опциональным (и не валидировать, если страна не ru), либо генерировать только для ru.

Как сделать “прикольно” и реалистично для РФ
Предлагаю расширить модель российских паспортов до 3 связанных полей плюс логика замены по возрасту:
- passport_data: "SSSS NNNNNN" — серия+номер. Серия SSSS состоит из:
  - SS_регион: первые 2 цифры — код региона/территории (например, 77 Москва, 50 Московская область, 78 Санкт‑Петербург, 23 Краснодарский край и т.п.). Список можно зашить словарём, задать веса под вашу географию.
  - SS_год: последние 2 цифры — год выдачи (YY).
- passport_department_code: "XXX-YYY" — код подразделения, где XXX — тот же регион (первые 3 цифры кода подразделения, обычно совпадает по региону с серией), YYY — номер подразделения 001–999.
- passport_issue_date: ISO-8601 дата выдачи (например, "2018-06-14").
- Необязательное, но полезное: birth_date — дата рождения клиента. Она позволит связать issue_date с возрастными этапами.

Алгоритм генерации для RU
- Генерация birth_date:
  - Выберите возрастное распределение ваших клиентов (например, 18–80, с пиком 25–45). Сгенерируйте birth_date.
- Определение окна выдачи паспорта:
  - В РФ внутренний паспорт впервые получают в 14 лет; обязательные замены в 20 и 45 лет.
  - Пусть visit_date уже есть. Рассчитайте возраст на момент визита и выберите issue_date:
    - Если возраст < 20: issue_date ∈ [14 лет, мин(возраст, visit_date)].
    - Если 20 ≤ возраст < 45: issue_date ∈ [20 лет, visit_date].
    - Если возраст ≥ 45: issue_date ∈ [45 лет, visit_date].
  - Не ставьте issue_date до 1997-10-01 (введение нового образца). Если окно начинается раньше — сдвиньте начало на 1997-10-01.
- Регион:
  - Выберите region_code из подготовленного списка (например, {77, 50, 78, 23, 66, 54, 16, 02, 52, 61, …}) с весами. Этот же регион используйте в department_code и в серии.
- Серия:
  - series = f"{region_code:02d}{issue_date.year % 100:02d}".
- Номер:
  - number = случайные 6 цифр (000001–999999) с исключением слишком “подозрительных” последовательностей по желанию (например, все нули).
- Код подразделения:
  - passport_department_code = f"{region_code:03d}-{unit:03d}", где unit ∈ [001..999].
- Итог:
  - passport_data = f"{series} {number}".

Валидация RU
- Формат проверок:
  - passport_data: r"^\d{4} \d{6}$".
  - passport_department_code: r"^\d{3}-\d{3}$".
  - passport_issue_date: корректная дата ISO-8601; ≥ 1997-10-01; ≤ visit_date.
- Согласованность:
  - series_year = int(series[2:4]) должен равняться issue_date.year % 100.
  - series_region = int(series[0:2]) должен совпадать с int(department_code[0:3] // 1) по региональному префиксу. Рекомендуется маппинг: первые 2 цифры серии == первые 2 цифры кода подразделения (или более строгая таблица, если захотите).
  - Если есть birth_date: проверьте возрастные окна:
    - issue_date ≥ birth_date + 14 лет,
    - если возраст на визит ≥ 20, то issue_date ≥ birth_date + 20 лет в случае замены; для простоты разрешите любой issue_date после соответствующего порога (не требуйте “в точную дату”).
- Ошибки:
  - Возвращайте человекочитаемые ошибки: “Серия не соответствует году выдачи”, “Код подразделения не соответствует региону серии”, “Дата выдачи позже даты визита”, “Дата выдачи раньше 14-летия” и т.п.

BY и KZ (минимально, но без ложных срабатываний)
- BY: r"^[A-Z]{2}\d{7}$" (оставьте, можно сузить набор букв до допустимых BY и добавить контроль по году выдачи/серии, если захотите).
- KZ: r"^N\d{8}$" (как у вас), можно добавить дату выдачи и проверять, что не в будущем.
- Валидация BY/KZ должна срабатывать только когда passport_country == 'by' или 'kz'.

Интеграция в ваш генератор/валидатор
- В generate_visit_record добавьте:
  - 'passport_country': client['country']
  - 'passport_issue_date' (для всех стран, хотя строгую проверку ввести пока для RU),
  - 'passport_department_code' (для RU), при BY/KZ можно не добавлять или оставить пустым.
  - По возможности добавьте 'birth_date' в клиента и не обязательно сохраняйте её в Excel (но она нужна валидатору).
- В validate_record:
  - Передавайте фактическую страну из record['passport_country'].
  - Если страна != 'ru', не валидируйте СНИЛС (или допускайте пустой).
  - Для RU вызывайте расширенную проверку: validate_passport_ru(passport_data, passport_issue_date, passport_department_code, visit_date, birth_date?).
  - Оставьте validate_passport_format как тонкий роутер по странам или разделите на validate_passport_ru/by/kz.
- В save_to_excel:
  - Добавьте столбцы “Страна паспорта”, “Дата выдачи паспорта”, “Код подразделения” (опционально).
- В UniquenessTracker:
  - Можно оставить как есть; паспорт RU/BY/KZ не пересекается по строковому формату. Если хотите строгости — храните ключ как (country, passport_data).

Тесты и диагностика
- Сгенерируйте небольшой датасет (1000–5000 записей) и проверьте:
  - Нет предупреждений по формату паспортов.
  - Для RU доля ошибок валидации ≈ 0.
  - В выборке проверьте, что series_year == issue_year % 100 и region совпадает с department_code.
- Логируйте 1–2 примера на партию с полным раскладом паспорта.

Большой абзац для копирования в исправления
В генераторе записей нужно начать записывать страну паспорта в каждую запись и перестать проверять BY/KZ паспорта по RU-шаблону: в методе DatasetGenerator.generate_visit_record при формировании record добавь ключ 'passport_country': client['country'] и, для РФ, сгенерируй ещё два поля: 'passport_issue_date' (ISO дата выдачи) и 'passport_department_code' в формате "XXX-YYY", где первые три цифры соответствуют региону; сами значения паспорта для РФ формируй так: серия SSSS = RRYY (RR — двузначный код региона из заданного словаря с весами, YY — год выдачи % 100), номер NNNNNN — шесть цифр, department_code = RRR-UUU, где RRR начинается тем же RR (например, 077-123 для Москвы), а дату выдачи выбирай в зависимости от возраста (первый паспорт не раньше 14 лет, замены в 20 и 45; окно — от соответствующего дня рождения до даты визита, но не раньше 1997-10-01); при этом 'passport_data' формируй как "SSSS NNNNNN". В валидаторе замени текущий validate_passport_format на роутер по странам: для 'ru' вызывай новый validate_passport_ru(passport_data, passport_issue_date, passport_department_code, visit_date, birth_date?) с проверками: (1) формат "^\d{4} \d{6}$", (2) "^\d{3}-\d{3}$" для кода подразделения, (3) серия[2:4] == issue_year % 100, (4) первые 2 цифры серии совпадают с первыми 2 цифрами кода подразделения, (5) issue_date не в будущем относительно visit_date и не раньше 1997-10-01, (6) при наличии birth_date — issue_date ≥ 14-летия, а для возрастов 20/45 — не раньше соответствующего порога; для 'by' оставь шаблон "^[A-Z]{2}\d{7}$" (по желанию сузить алфавит), для 'kz' — "^N\d{8}$", без привязки к RU-правилам; дополнительно в validate_record возьми страну строго из record['passport_country'] без дефолта в "ru", а проверку СНИЛС выполняй только для 'ru' (для других стран либо разрешай пустой, либо не проверяй); в сохранение Excel добавь колонки “Страна паспорта”, “Дата выдачи паспорта”, “Код подразделения”. Это автоматически устранит текущие предупреждения “Неверный формат паспорта для страны ru” (они возникают, потому что сейчас в record нет passport_country и все не-RU номера проверяются как RU) и сделает российские паспорта согласованными по региону, году выдачи и возрастной логике.

Если хотите, могу затем набросать словарь регионов с весами и точные сигнатуры функций для utils/validators, чтобы это быстро собрать.
```

4. Написать мне концепцию для обсуждения с преподавателем про СНИЛС (в отдельном файле). Т.к. у нас paid-clinic то вроде как в РФ им СНИЛС нужен исключительно для того чтобы посмотреть историю болезни/мед.историю. Но СНИЛС автоматически не появляется у жителей BY и KZ, потому что там другое. Соответственно СНИЛС это не "платёжный документ", т.е. мы не можем писать его для граждан RU, а для остальных вместо него писать `paid`, НЕТ! Мы так не можем! Потому что у нас все paid, а СНИЛС - лишь источник данных. Соответственно предложи какой аналог СНИЛС может быть для граждан BY и KZ и чтобы это всё было похоже на правду. В коде оставь снилс у всех пока-что.
5. Проверь есть ли более чёткие правила формирования СНИЛС, как для паспорта.
6. Сверь, что ты не добавил лишние столбцы в таблицу, а всё чётко по заданию. Изначальное задание описано в README.md/
7. Проверь ещё раз пристально ВСЁ на соответствие
8. Доделай все разхождения с изначальным заданием.
9. Не запускай тест данных с размером таблицы больше 100, иначе у тебя токены закончатся.
10. Почини стоимость. Я вообще не понял почему стоимость за анализы может плавать. Вроде везде она фиксированная.
11. Написать красивый человеческий (без смайликов и сложных знаков и т.д.) отчёт по этой структуре (очень человеческий, а не нейросетевой, но серьёзный и настоящий)
```
## Содержание отчёта
1. Цель работы.
2. Описание задачи (формализация задачи).
3. Теоретическая часть (краткое описание создания датасета и его правил с ограничениями).
4. Описание блок-схемы пошагового выполнения алгоритма.
5. Описание программы (представление программы на выбранном языке, спецификация программы — описание классов и т. п.).
6. Рекомендации пользователя.
7. Рекомендации программиста.
8. Описание контрольного примера (демонстрация, как можно редактировать различные критерии для изменения входных параметров датасета).
9. Вывод по работе.
```
12. Удали лишние README_PART<...> и может быть README_FINAL_SUMMART почисти от всего очевидного, чтобы я быстро посмотрел и удалил его.
13. НЕ МЕНЯЙ НАСТОЯЩИЙ README.md, он для тебя read-only.
14. Удали лишние очевидные комментарии по файлам, лишние функции, лишние fallback.
15. Перепроверь всё второй раз и заверши MVP готовый к сдаче.